# 你不懂JS: *this* & Object Prototypes
# 第一章: `this` 还是 That？

Javascript中最令人困惑的机制之一就是`this`关键字。它是一个自动定义每个函数作用域的特殊识别符，但是即便是一些老练的开发者也感到困扰——它到底指向哪里。

> 任何足够“先进”的技术都跟魔法没有区别。-- Arthur C. Clarke

实际上Javascript的`this`机制没有“那么”先进，但是开发者们总是引用这句话来表达“复杂”和“混乱”，毫无疑问，如果没有清晰的认识，在*你的*混乱中`this`看起来就是彻头彻尾的魔法。

**注意：** `this`这个词是在一般的论述中极其通用的代词。所以——特别是在口头论述中——很难确定我们是在用`this`作为一个代词，还是在将它作为一个实际的关键字识别符。为了表意清晰，我会总是用`this`来代表那个特殊的关键字，而在其他情况下使用“this”或*this*。

## 为什么用 `this`？

如果对于那些老练的Javascript开发者来说`this`机制都是如此的令人费解，那人们会问为什么这种机制会有用？它带来的好处会比麻烦多吗？在解释*如何*有用之前，我们应当先来看看*为什么*有用。

让我试着描绘一下`this`的动机和效用：

```js
function identify() {
	return this.name.toUpperCase();
}

function speak() {
	var greeting = "Hello, I'm " + identify.call( this );
	console.log( greeting );
}

var me = {
	name: "Kyle"
};

var you = {
	name: "Reader"
};

identify.call( me ); // KYLE
identify.call( you ); // READER

speak.call( me ); // Hello, I'm KYLE
speak.call( you ); // Hello, I'm READER
```

如果这个代码片段的工作方式让你困惑，不要担心！我们很快就会解释它。我只是简略地将这些问题放在旁边，以便于我们可以更清晰的研究*为什么*。

这个代码片段允许`identify()`和`speak()`函数对多个**环境**对象（`me`和`you`）进行复用，而不是针对每个对象定义函数的不同版本。

通过使用`this`，你可以明确地将环境对象传递给`identify()`和`speak()`函数。

```js
function identify(context) {
	return context.name.toUpperCase();
}

function speak(context) {
	var greeting = "Hello, I'm " + identify( context );
	console.log( greeting );
}

identify( you ); // READER
speak( me ); // Hello, I'm KYLE
```

然而，`this`机制提供了更优雅的方式来隐含地“传入”一个对象引用，发展出更加干净的API设计和更容易的复用。

你的使用模式越复杂，你就会越清晰地感觉到：将执行环境作为一个参数传递，通常比传递`this`执行环境要乱。当我们探索objects和prototypes时，你将会看到一组可以自动指向合适的执行环境的函数，以及它们是多么有用。

## 困惑

我们很快就要开始解释`this`是如何**实际**工作的，但我们首先要抛弃一些错误概念——它实际上**不是**如何工作的。

在开发者们用太过于字面的方式考虑`this`这个名字时，困惑就产生了。这通常会产生两种臆测，但都是不对的。

### 它自己

第一种通常的倾向是，臆测`this`指向函数自己。这至少是一种语法上的合理推测。

为什么你想要在函数内部引用它自己？最通常的理由是递归（在函数内部调用它自己），或者是有一个在第一次别调用时会解除自己绑定的事件处理器。（TODO）

初次接触JS机制的开发者们通常认为，将函数作为一个对象引用，可以让你在方法调用之间储存一些**状态**（值和属性）。这当然是可能的，而且有一些有限的用处，但这本书的其余部分将会阐述许多其他的模式，来找到比函数对象**更好**的地方来存储状态。

我们来看看一个模式，来展示`this`是如何不让一个函数向我们想象的那样，得到它自身的引用的。

考虑下面的代码，我们试图追踪函数(`foo`)被调用的多少次：

```js
function foo(num) {
	console.log( "foo: " + num );

	// keep track of how many times `foo` is called
	this.count++;
}

foo.count = 0;

var i;

for (i=0; i<10; i++) {
	if (i > 5) {
		foo( i );
	}
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// `foo`别调用了多少次？
console.log( foo.count ); // 0 -- 这他妈怎么回事……？
```

`foo.count`**依然**是`0`, 即便四个`console.log`语句明明告诉我们`foo(..)`实际上被调用了四次。这种尝试的失败来源于对于`this` (在`this.count++`中)的含义的过于字面化的理解。

当执行代码`foo.count = 0`时，确实在函数对象`foo`中加入了一个`count`属性。但是对于函数内部的`this.count`引用，`this`其实**根本就不**指向那个函数对象，即便属性名称一样，但根对象也不同，困惑应运而生。

**注意：** 一个负责任的开发者应当在这里提出一个问题：“如果我递增的`count`属性不是我以为的那个，那是哪个`count`被我递增了？”。实际上——如果他再挖的深一些——他会发现自己不小心创建了一个全局变量`count`（第二章解释了这是如何发生的），而且它当前的值是`NaN`。当然，一旦他发现这个不寻常的结果后，他会有一堆其他的问题：“它怎么是全局的？为什么它是`NaN`而不是某个合适的值？”。（见第二章）

相较于停在这里来深究为什么`this`引用看起来不是如我们期待的那样工作，并且回答那些尖锐且重要的问题，许多开发者简单地回避这个现象，转向一些其他的另类解决方法，比如创建另一个对象来持有`count`属性：

```js
function foo(num) {
	console.log( "foo: " + num );

	// 追踪foo被调用了多少次
	data.count++;
}

var data = {
	count: 0
};

var i;

for (i=0; i<10; i++) {
	if (i > 5) {
		foo( i );
	}
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// foo被调用了多少次？
console.log( data.count ); // 4
```

当然这种方式确实“解决”了问题，不幸的是它简单地忽略了真正的问题——缺乏对于`this`的含义和其工作方式上的理解——并且推回到了一个更加熟悉的舒适区：词法作用域。

**注意：** 词法作用域是一个完善且有用的机制；从任何角度来说，我不是在贬低对于它的使用（参见本系列的*"Scope & Closures"*）。但总是靠**猜**，而且通常都是**错误地**解释如何使用`this`，并不是一个退回到词法作用域的好理由，也不是从不学习**为什么**`this`不如你所愿的好理由。

为了从函数对象自身中引用它自己，一般来说通过`this`是不够的。你用通常需要一个指向函数对象引用的词法标识符（变量）。

考虑这两个函数：

```js
function foo() {
	foo.count = 4; // `foo` 引用它自己
}

setTimeout( function(){
	// 匿名函数不能引用它自己
}, 10 );
```

第一个函数，称为“命名函数”，`foo`是一个引用，可以用于在它自身内部引用自己。

但是在得二个例子中，传递给`setTimeout(..)`的回调函数没有名称标识符（所谓的“匿名函数”），所以没有办法从它自身引用自己的函数对象。

**注意：**在函数中有一个老牌儿但是现在被废弃的，而且令人皱眉头的`arguments.callee`引用**也**指向正在执行的函数的函数对象。这个引用一般来说是匿名函数在自己内部访问函数对象的唯一方法。然而，最佳的办法是完全避免使用匿名函数——至少是对于那些需要自引用的函数——而使用命名函数（表达式）。`arguments.callee`已经被废弃而且不应该再使用。

所以对于当前我们的例子来说，另一个“**好用的**”解决方案是在每一个地方都使用`foo`标识符作为函数对象的引用，而根本不用`this`：

```js
function foo(num) {
	console.log( "foo: " + num );

	// 追踪`foo`被调用了多少次
	foo.count++;
}

foo.count = 0;

var i;

for (i=0; i<10; i++) {
	if (i > 5) {
		foo( i );
	}
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// `foo`被调用了多少次？
console.log( foo.count ); // 4
```

然而，这种方法也类似地回避了对`this`的**真正**理解，而且完全依靠变量`foo`的词法作用域。

另一种方法是强迫`this`指向`foo`函数对象：

```js
function foo(num) {
	console.log( "foo: " + num );

	// 追踪`foo`被调用了多少次
	// 注意：由于`foo`的被调用方式（见下方），`this`现在确实是`foo`
	this.count++;
}

foo.count = 0;

var i;

for (i=0; i<10; i++) {
	if (i > 5) {
		// 使用 `call(..)`，我们可以保证`this`指向函数对象(`foo`) 
		foo.call( foo, i );
	}
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9

// `foo`被调用了多少次？
console.log( foo.count ); // 4
```

**与回避`this`相反，我们拥抱它。**我们将会更完整地解释一些这种技术如何工作，所以如果你依然很困惑，不要担心！

### 它的作用域

对`this`的含义第二多的错误概念，是它不知怎样地指向了函数的作用域。这是一个刁钻的问题，因为在某一种意义上它有正确的部分，而在另外一种意义上，它是严重的误导。

明确地说，`this`不会以任何方式指向函数的**词法作用域**。作用域好像是一个将所有可用标识符作为属性的对象，这从内部来说是对的。但是Javascript代码不可以访问作用域“对象”。它是**引擎**的内部实现。

考虑下面代码，它（失败的）企图跨越这个边界，用`this`来隐含地引用函数的词法作用域：

```js
function foo() {
	var a = 2;
	this.bar();
}

function bar() {
	console.log( this.a );
}

foo(); //undefined
```

这个代码段里不只有一个错误。虽然它看起来是在故意瞎搞，但你看到的这段代码，是在公共的帮助论坛社区中被交换的真实代码的提纯物。真实难以想象对`this`的臆想是多么的误导人。

首先，试图通过`this.bar()`来引用`bar()`函数。它几乎可以说是**碰巧**能够工作，我们过一会儿再解释为什么。调用`bar()`最自然的方式是省略开头的 `this.`，而仅使用标识符的词法引用。

然而，写这段代码的开发者试图用`this`来建立一座桥来连接`foo()`和`bar()`的词法作用域，所以`bar()`可以访问位于`foo()`内部作用域的变量`a`。**这种桥接是不可能的。**你不能用`this`引用来查找词法作用域中的东西。那是不可能的。

每当你觉得你自己在试着将词法作用域查询和`this`混在一起时，提醒你自己：**这里没有桥**。

## 什么是 `this`？

在列举了种种不正确的臆想之后，现在让我们将注意力转向`this`机制实际上是如何工作的。

我们以前说过，`this`不是一个编写时绑定，而是一个运行时绑定。它基于函数调用的上下文条件（TODO）。`this`绑定与函数在哪里声明无关，而与函数被调用的方式有关。

当函数别调用时，一个活动记录，也被称为执行上下文环境，会被建立。这个记录含有：函数在哪里被调用（调用栈——call-stack），函数是如何被调用的，什么参数被传递了，等等信息。在那个函数执行期间将被使用的`this`引用就是这个记录的属性之一。

在下一章中，我们将会学习找到函数的**调用点（call-site）**来决定它的执行过程如何绑定`this`.

## 复习 (TL;DR)

对于那些没有花过时间学习这种机制究竟如何工作的Javascript开发者而言，`this`绑定一直是困惑的根源。猜测，试错，从Stack Overflow的答案中盲目地复制粘贴，都不是利用这个重要的`this`机制的有效或合适的方法。

为了学习`this`，你首先不得不学习`this`**不是**什么，不管什么臆测或误解将你引入歧途。`this`既不是函数自身的引用，也不是函数**词法**作用域的引用。

`this`实际上是一个在函数被调用时制造的绑定，它指向**什么**，是完全由函数被调用时的调用点决定的。
